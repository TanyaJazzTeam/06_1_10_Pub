## Небезопасная ржавчина

Во всем коде, который мы обсуждали до сих пор, гарантии безопасности памяти Rust применялись во время компиляции. Однако внутри Rust спрятан второй язык, который не обеспечивает эти гарантии безопасности памяти: он называется *небезопасным Rust* и работает так же, как обычный Rust, но дает нам дополнительные сверхспособности.

Небезопасный Rust существует потому, что по своей природе статический анализ консервативен. Когда компилятор пытается определить, поддерживает ли код гарантии, для него лучше отклонить некоторые допустимые программы, чем принять некоторые недопустимые программы. Хотя код *может* быть в порядке, если у компилятора Rust недостаточно информации, чтобы быть уверенным, он отклонит код. В этих случаях вы можете использовать небезопасный код, чтобы сказать компилятору: «Поверьте мне, я знаю, что делаю». Однако имейте в виду, что вы используете небезопасный Rust на свой страх и риск: если вы неправильно используете небезопасный код, могут возникнуть проблемы из-за небезопасности памяти, такие как разыменование нулевого указателя.

Еще одна причина, по которой у Rust есть небезопасное альтер-эго, заключается в том, что базовое компьютерное оборудование небезопасно по своей природе. Если бы Rust не позволял выполнять небезопасные операции, вы не могли бы выполнять определенные задачи. Rust должен позволять вам выполнять низкоуровневое системное программирование, например, напрямую взаимодействовать с операционной системой или даже писать собственную операционную систему. Работа с низкоуровневым системным программированием является одной из целей языка. Давайте посмотрим, что мы можем сделать с небезопасным Rust и как это сделать.

### Небезопасные сверхспособности

Чтобы переключиться на небезопасный Rust, используйте ключевое слово `unsafe` , а затем запустите новый блок, содержащий небезопасный код. Вы можете выполнить пять действий в небезопасном Rust, которые вы не можете сделать в безопасном Rust, которые мы называем *небезопасными сверхспособностями* . Эти сверхспособности включают в себя способность:

- Разыменование необработанного указателя
- Вызов небезопасной функции или метода
- Доступ или изменение изменяемой статической переменной
- Реализовать небезопасный трейт
- Доступ к полям `union` s

Важно понимать, что `unsafe` не отключает проверку заимствования или какие-либо другие проверки безопасности Rust: если вы используете ссылку в небезопасном коде, она все равно будет проверена. Ключевое слово `unsafe` дает вам доступ только к этим пяти функциям, которые затем не проверяются компилятором на безопасность памяти. Вы все равно получите некоторую степень безопасности внутри небезопасного блока.

Кроме того, `unsafe` не означает, что код внутри блока обязательно опасен или что у него определенно будут проблемы с безопасностью памяти: цель состоит в том, чтобы как программист вы обеспечили доступ кода внутри `unsafe` блока к памяти допустимым способом. .

Люди подвержены ошибкам, и ошибки случаются, но требуя, чтобы эти пять небезопасных операций были внутри блоков, аннотированных словом `unsafe` , вы будете знать, что любые ошибки, связанные с безопасностью памяти, должны быть внутри `unsafe` блока. Держите `unsafe` блоки маленькими; вы будете благодарны позже, когда будете исследовать ошибки памяти.

Чтобы максимально изолировать небезопасный код, лучше всего заключить небезопасный код в безопасную абстракцию и предоставить безопасный API, который мы обсудим позже в этой главе, когда будем рассматривать небезопасные функции и методы. Части стандартной библиотеки реализованы как безопасные абстракции над небезопасным кодом, прошедшим аудит. Обертывание небезопасного кода в безопасную абстракцию предотвращает утечку использования `unsafe` во все места, где вы или ваши пользователи могли бы захотеть использовать функциональность, реализованную с помощью `unsafe` кода, потому что использование безопасной абстракции безопасно.

Давайте по очереди рассмотрим каждую из пяти небезопасных сверхспособностей. Мы также рассмотрим некоторые абстракции, обеспечивающие безопасный интерфейс для небезопасного кода.

### Разыменование необработанного указателя

В главе 4, в разделе [«Висячие ссылки».](ch04-02-references-and-borrowing.html#dangling-references)<!-- игнорировать --> мы упомянули, что компилятор гарантирует, что ссылки всегда действительны. В Unsafe Rust есть два новых типа, называемых *необработанными указателями* , похожими на ссылки. Как и в случае со ссылками, необработанные указатели могут быть неизменяемыми или изменяемыми и записываются как `*const T` и `*mut T` соответственно. Звездочка не является оператором разыменования; это часть имени типа. В контексте необработанных указателей *неизменяемость* означает, что указатель не может быть напрямую назначен после разыменования.

В отличие от ссылок и интеллектуальных указателей, необработанные указатели:

- Разрешено игнорировать правила заимствования, имея как неизменяемые, так и изменяемые указатели или несколько изменяемых указателей на одно и то же место.
- Не гарантируется указание на действительную память
- Допускается быть нулевым
- Не применять автоматическую очистку

Отказавшись от принудительного применения этих гарантий Rust, вы можете отказаться от гарантированной безопасности в обмен на более высокую производительность или возможность взаимодействия с другим языком или оборудованием, на которые гарантии Rust не распространяются.

В листинге 19-1 показано, как создать неизменяемый и изменяемый необработанный указатель из ссылок.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-01/src/main.rs:here}}
```

<span class="caption">Листинг 19-1: Создание необработанных указателей из ссылок</span>

Обратите внимание, что мы не включаем ключевое слово `unsafe` в этот код. Мы можем создавать необработанные указатели в безопасном коде; мы просто не можем разыменовывать необработанные указатели за пределами небезопасного блока, как вы вскоре увидите.

Мы создали необработанные указатели, используя `as` для приведения неизменяемой и изменяемой ссылки к соответствующим типам необработанных указателей. Поскольку мы создали их непосредственно из ссылок, которые гарантированно являются действительными, мы знаем, что эти конкретные необработанные указатели действительны, но мы не можем сделать такое предположение о любом необработанном указателе.

Чтобы продемонстрировать это, далее мы создадим необработанный указатель, в достоверности которого мы не можем быть уверены. В листинге 19-2 показано, как создать необработанный указатель на произвольное место в памяти. Попытка использовать произвольную память не определена: по этому адресу могут быть данные, а может и нет, компилятор может оптимизировать код, чтобы не было доступа к памяти, или программа может выдать ошибку сегментации. Обычно нет веских причин писать такой код, но это возможно.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-02/src/main.rs:here}}
```

<span class="caption">Листинг 19-2: Создание необработанного указателя на произвольный адрес памяти</span>

Вспомните, что мы можем создавать необработанные указатели в безопасном коде, но мы не можем *разыменовывать* необработанные указатели и читать данные, на которые указывают. В листинге 19.3 мы используем оператор разыменования `*` для необработанного указателя, для которого требуется `unsafe` блок.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-03/src/main.rs:here}}
```

<span class="caption">Листинг 19-3: Разыменование необработанных указателей в <code>unsafe</code> блоке</span>

Создание указателя не навредит; только когда мы пытаемся получить доступ к значению, на которое он указывает, мы можем в конечном итоге иметь дело с недопустимым значением.

Также обратите внимание, что в листингах 19-1 и 19-3 мы создали необработанные указатели `*const i32` и `*mut i32` , которые указывали на одну и ту же ячейку памяти, где хранится `num` . Если бы вместо этого мы попытались создать неизменяемую и изменяемую ссылку на `num` , код не скомпилировался бы, потому что правила владения Rust не разрешают изменяемую ссылку одновременно с любыми неизменяемыми ссылками. С необработанными указателями мы можем создать изменяемый указатель и неизменный указатель на одно и то же место и изменять данные с помощью изменяемого указателя, потенциально создавая гонку данных. Будь осторожен!

Со всеми этими опасностями, зачем вообще использовать необработанные указатели? Одним из основных вариантов использования является взаимодействие с кодом C, как вы увидите в следующем разделе [«Вызов небезопасной функции или метода».](#calling-an-unsafe-function-or-method)<!-- игнорировать --> Другой случай — создание безопасных абстракций, которые не понимает средство проверки заимствования. Мы представим небезопасные функции, а затем рассмотрим пример безопасной абстракции, использующей небезопасный код.

### Вызов небезопасной функции или метода

Второй тип операций, которые вы можете выполнять в небезопасном блоке, — это вызов небезопасных функций. Небезопасные функции и методы выглядят точно так же, как обычные функции и методы, но перед остальным определением у них есть дополнительный `unsafe` . Ключевое слово `unsafe` в этом контексте указывает на то, что у функции есть требования, которые мы должны соблюдать при вызове этой функции, потому что Rust не может гарантировать, что мы выполнили эти требования. Вызывая небезопасную функцию в `unsafe` блоке, мы говорим, что прочитали документацию по этой функции и берем на себя ответственность за соблюдение контрактов функции.

Вот небезопасная функция с именем `dangerous` , которая ничего не делает в своем теле:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-01-unsafe-fn/src/main.rs:here}}
```

Мы должны вызывать `dangerous` функцию в отдельном `unsafe` блоке. Если мы попытаемся вызвать `dangerous` без блока `unsafe` , то получим ошибку:

```console
{{#include ../listings/ch19-advanced-features/output-only-01-missing-unsafe/output.txt}}
```

Блоком `unsafe` мы утверждаем для Rust, что прочитали документацию по функции, понимаем, как ее правильно использовать, и убедились, что выполняем контракт функции.

Тела небезопасных функций фактически являются `unsafe` блоками, поэтому для выполнения других небезопасных операций внутри небезопасной функции нам не нужно добавлять еще один `unsafe` блок.

#### Создание безопасной абстракции над небезопасным кодом

Тот факт, что функция содержит небезопасный код, не означает, что мы должны помечать всю функцию как небезопасную. На самом деле, перенос небезопасного кода в безопасную функцию — это обычная абстракция. В качестве примера изучим функцию `split_at_mut` из стандартной библиотеки, которая требует некоторого небезопасного кода. Мы рассмотрим, как мы могли бы реализовать это. Этот безопасный метод определен для изменяемых слайсов: он берет один слайс и делает из него два, разбивая слайс по индексу, указанному в качестве аргумента. В листинге 19-4 показано, как использовать `split_at_mut` .

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-04/src/main.rs:here}}
```

<span class="caption">Листинг 19-4: Использование безопасной функции <code>split_at_mut</code></span>

Мы не можем реализовать эту функцию, используя только безопасный Rust. Попытка может выглядеть примерно так, как показано в листинге 19.5, но не компилируется. Для простоты мы реализуем `split_at_mut` как функцию, а не как метод, и только для срезов значений `i32` , а не для универсального типа `T`

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-05/src/main.rs:here}}
```

<span class="caption">Листинг 19-5: Попытка реализации <code>split_at_mut</code> с использованием только безопасного Rust</span>

Эта функция сначала получает общую длину среза. Затем он утверждает, что индекс, указанный в качестве параметра, находится внутри среза, проверяя, меньше ли он длины или равен ему. Утверждение означает, что если мы передаем индекс, который больше, чем длина для разделения среза, функция запаникует, прежде чем попытается использовать этот индекс.

Затем мы возвращаем два изменяемых среза в кортеже: один от начала исходного среза до `mid` индекса, а другой от `mid` до конца среза.

Когда мы попытаемся скомпилировать код из листинга 19-5, мы получим ошибку.

```console
{{#include ../listings/ch19-advanced-features/listing-19-05/output.txt}}
```

Средство проверки заимствования Rust не может понять, что мы заимствуем разные части среза; он знает только, что мы дважды заимствуем один и тот же фрагмент. Заимствование разных частей слайса в принципе допустимо, потому что два слайса не перекрываются, но Rust недостаточно умен, чтобы знать об этом. Когда мы знаем, что с кодом все в порядке, а с Rust — нет, пора заняться небезопасным кодом.

В листинге 19-6 показано, как использовать `unsafe` блок, необработанный указатель и некоторые вызовы небезопасных функций, чтобы реализация `split_at_mut` работала.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-06/src/main.rs:here}}
```

<span class="caption">Листинг 19-6: Использование небезопасного кода в реализации функции <code>split_at_mut</code></span>

Напомним из [«Тип среза»]<!-- игнорировать --> в главе 4, что слайсы являются указателем на некоторые данные и длину слайса. Мы используем метод `len` для получения длины среза и метод `as_mut_ptr` для доступа к необработанному указателю среза. В этом случае, поскольку у нас есть изменяемый срез со значениями `i32` , `as_mut_ptr` возвращает необработанный указатель с типом `*mut i32` , который мы сохранили в переменной `ptr` .

Мы сохраняем утверждение, что `mid` индекс находится внутри среза. Затем мы переходим к небезопасному коду: функция `slice::from_raw_parts_mut` принимает необработанный указатель и длину и создает срез. Мы используем эту функцию для создания фрагмента, который начинается с `ptr` и имеет длину `mid` элементов. Затем мы вызываем метод `add` для `ptr` с `mid` в качестве аргумента, чтобы получить необработанный указатель, который начинается с `mid` , и мы создаем срез, используя этот указатель и оставшееся количество элементов после `mid` в качестве длины.

Функция `slice::from_raw_parts_mut` небезопасна, потому что она принимает необработанный указатель и должна доверять этому указателю. Метод `add` для необработанных указателей также небезопасен, поскольку он должен доверять тому, что местоположение смещения также является допустимым указателем. Поэтому нам пришлось поставить `unsafe` блок вокруг наших вызовов `slice::from_raw_parts_mut` и `add` , чтобы мы могли их вызывать. Глядя на код и добавляя утверждение, что `mid` должно быть меньше или равно `len` , мы можем сказать, что все необработанные указатели, используемые в `unsafe` блоке, будут действительными указателями на данные в срезе. Это приемлемое и уместное использование `unsafe` .

Обратите внимание, что нам не нужно помечать полученную функцию `split_at_mut` как `unsafe` , и мы можем вызвать эту функцию из безопасного Rust. Мы создали безопасную абстракцию для небезопасного кода с реализацией функции, которая использует `unsafe` код безопасным способом, поскольку она создает только допустимые указатели из данных, к которым эта функция имеет доступ.

Напротив, использование `slice::from_raw_parts_mut` в листинге 19.7, скорее всего, приведет к сбою при использовании среза. Этот код берет произвольное место в памяти и создает срез длиной 10 000 элементов.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-07/src/main.rs:here}}
```

<span class="caption">Листинг 19-7: Создание слайса из произвольной области памяти</span>

Мы не владеем памятью в этом произвольном месте, и нет гарантии, что срез, который создает этот код, содержит действительные значения `i32` . Попытка использовать `values` , как будто это допустимый срез, приводит к неопределенному поведению.

#### Использование `extern` функций для вызова внешнего кода

Иногда вашему коду на Rust может потребоваться взаимодействие с кодом, написанным на другом языке. Для этого в Rust есть ключевое слово `extern` , которое облегчает создание и использование *интерфейса внешних функций (FFI)* . FFI — это способ, с помощью которого язык программирования определяет функции и позволяет другому (иностранному) языку программирования вызывать эти функции.

В листинге 19-8 показано, как настроить интеграцию с функцией `abs` из стандартной библиотеки C. Функции, объявленные в блоках `extern` , всегда небезопасно вызывать из кода Rust. Причина в том, что другие языки не применяют правила и гарантии Rust, а Rust не может их проверить, поэтому ответственность за обеспечение безопасности ложится на программиста.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-08/src/main.rs}}
```

<span class="caption">Листинг 19-8: Объявление и вызов <code>extern</code> функции, определенной на другом языке</span>

Во `extern "C"` мы перечисляем имена и сигнатуры внешних функций из другого языка, которые мы хотим вызвать. Часть `"C"` определяет, какой *двоичный интерфейс приложения (ABI)* использует внешняя функция: ABI определяет, как вызывать функцию на уровне сборки. ABI `"C"` является наиболее распространенным и соответствует ABI языка программирования C.

> #### Вызов функций Rust из других языков
>
> Мы также можем использовать `extern` для создания интерфейса, позволяющего другим языкам вызывать функции Rust. Вместо того, чтобы создавать целый блок `extern` , мы добавляем ключевое слово `extern` и указываем ABI для использования непосредственно перед ключевым словом `fn` для соответствующей функции. Нам также нужно добавить аннотацию `#[no_mangle]` , чтобы указать компилятору Rust не изменять имя этой функции. *Искажение* — это когда компилятор изменяет имя, которое мы дали функции, на другое имя, которое содержит больше информации для других частей процесса компиляции, но менее удобочитаемо для человека. Компилятор каждого языка программирования искажает имена немного по-разному, поэтому, чтобы функцию Rust можно было назвать другими языками, мы должны отключить изменение имени компилятором Rust.
>
> В следующем примере мы делаем функцию `call_from_c` доступной из кода C после того, как она скомпилирована в разделяемую библиотеку и связана с C:
>
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
>
> Такое использование `extern` не требует `unsafe` .

### Доступ или изменение изменяемой статической переменной

В этой книге мы еще не говорили о *глобальных переменных* , которые Rust поддерживает, но может вызвать проблемы с правилами владения Rust. Если два потока обращаются к одной и той же изменяемой глобальной переменной, это может вызвать гонку данных.

В Rust глобальные переменные называются *статическими* переменными. В листинге 19-9 показан пример объявления и использования статической переменной со строковым фрагментом в качестве значения.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-09/src/main.rs}}
```

<span class="caption">Листинг 19-9: Определение и использование неизменяемой статической переменной</span>

Статические переменные похожи на константы, которые мы обсуждали в разделе [«Различия между переменными и константами».](ch03-01-variables-and-mutability.html#constants)<!-- игнорировать --> раздел в Главе 3. Имена статических переменных по соглашению находятся в `SCREAMING_SNAKE_CASE` . Статические переменные могут хранить ссылки только со `'static` временем жизни», что означает, что компилятор Rust может вычислить время жизни, и нам не требуется явно аннотировать его. Доступ к неизменяемой статической переменной безопасен.

Тонкое различие между константами и неизменяемыми статическими переменными заключается в том, что значения в статической переменной имеют фиксированный адрес в памяти. Использование значения всегда будет получать доступ к одним и тем же данным. Константы, с другой стороны, могут дублировать свои данные всякий раз, когда они используются. Еще одно отличие состоит в том, что статические переменные могут быть изменяемыми. Доступ и изменение изменяемых статических переменных *небезопасно* . В листинге 19-10 показано, как объявить, получить доступ и изменить изменяемую статическую переменную с именем `COUNTER` .

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-10/src/main.rs}}
```

<span class="caption">Листинг 19-10: Чтение или запись в изменяемую статическую переменную небезопасно</span>

Как и в случае с обычными переменными, мы указываем изменяемость с помощью ключевого слова `mut` . Любой код, читающий или записывающий из `COUNTER` , должен находиться в `unsafe` блоке. Этот код компилируется и выводит `COUNTER: 3` , как и следовало ожидать, потому что он однопоточный. Наличие нескольких потоков, обращающихся к `COUNTER` , скорее всего, приведет к гонкам данных.

С изменяемыми данными, которые доступны глобально, трудно гарантировать отсутствие гонок данных, поэтому Rust считает изменяемые статические переменные небезопасными. Там, где это возможно, предпочтительнее использовать методы параллелизма и потокобезопасные интеллектуальные указатели, которые мы обсуждали в главе 16, чтобы компилятор проверял, что доступ к данным из разных потоков выполняется безопасно.

### Реализация небезопасной черты

Мы можем использовать `unsafe` для реализации небезопасного трейта. Трейт небезопасен, если хотя бы один из его методов имеет некоторый инвариант, который компилятор не может проверить. Мы объявляем трейт `unsafe` , добавляя ключевое слово `unsafe` перед `trait` и помечая реализацию трейта как `unsafe` , как показано в листинге 19.11.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-11/src/main.rs}}
```

<span class="caption">Листинг 19-11. Определение и реализация небезопасного трейта</span>

Используя `unsafe impl` , мы обещаем, что будем поддерживать инварианты, которые компилятор не может проверить.

В качестве примера вспомните трейты маркера `Sync` и `Send` , которые мы обсуждали в разделе <a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits" data-md-type="link">«Расширяемый параллелизм с трейтами `Sync` и `Send` ».</a><!-- игнорировать --> раздел в главе 16: компилятор реализует эти свойства автоматически, если наши типы полностью состоят из типов `Send` и `Sync` . Если мы реализуем тип, который содержит тип, отличный от `Send` или `Sync` , например необработанные указатели, и мы хотим пометить этот тип как `Send` или `Sync` , мы должны использовать `unsafe` . Rust не может проверить, поддерживает ли наш тип гарантии того, что его можно безопасно передавать между потоками или получать к нему доступ из нескольких потоков; поэтому нам нужно выполнять эти проверки вручную и указывать это с помощью `unsafe` .

### Доступ к полям союза

Последним действием, которое работает только с `unsafe` , является доступ к полям *объединения* . `union` похоже на `struct` , но в конкретный момент времени используется только одно объявленное поле. Объединения в основном используются для взаимодействия с объединениями в коде C. Доступ к полям объединения небезопасен, потому что Rust не может гарантировать тип данных, которые в данный момент хранятся в экземпляре объединения. Вы можете узнать больше об объединениях в [Rust Reference] .

### Когда использовать небезопасный код

Использование `unsafe` для выполнения одного из пяти только что обсуждавшихся действий (сверхспособностей) не является неправильным и даже не осуждается. Но исправить `unsafe` код сложнее, потому что компилятор не может поддерживать безопасность памяти. Если у вас есть причина использовать `unsafe` код, вы можете это сделать, а наличие явной `unsafe` аннотации упрощает отслеживание источника проблем при их возникновении.


[«Тип среза»]: ch04-03-slices.html#the-slice-type
[Rust Reference]: ../reference/items/unions.html